<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Chat + Player Completo</title>
  <style>
    /* Estilos Globais e Reset */
    *{box-sizing:border-box;margin:0;padding:0}
    body{background:#121212;color:#EEE;font-family:Arial,sans-serif;display:flex;flex-direction:column;height:100vh;}
    .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0;}

    /* Telas de Setup e Espera (Menu Inicial, Nome, Aprovação, Recusado) */
    #menuSetup, #namePrompt, #waitingApproval, #rejectedNotice {
      padding:1rem; /* */
      display:flex; /* */
      flex-direction:column; /* */
      gap:.5rem; /* */
      align-items:center; /* */
      text-align:center; /* */
      justify-content: center; /* Centraliza verticalmente */
      flex: 1; /* */
    /* Permite que ocupe o espaço disponível */
    }

    /* Layout Principal da UI (PC Padrão) */
    #mainUI{
      display:none; /* Inicia oculto, será 'flex' após login */
      flex:1; /* Ocupa o espaço disponível */
      flex-direction:row; /* Player e Chat lado a lado no PC */
      max-width:1200px; /* Largura máxima para PCs */
      margin:0 auto; /* Centraliza */
      position:relative;
      padding: 1rem; /* Espaçamento interno */
    }

    /* Estilos do Player */
    #playerArea{
      flex:2; /* Ocupa 2/3 do espaço disponível */
      background:#222;
      display:flex;
      flex-direction:column;
      align-items:center;
      padding:1rem;
      position:relative;
      border-radius: 8px; /* Bordas arredondadas */
    }
    #mediaPlayerContainer { /* Novo contêiner para o player */
        width: 100%;
        max-width: 800px;
        position: relative;
        padding-top: 56.25%; /* Proporção 16:9 (altura/largura = 0.5625) */
        background: #000;
        border-radius: 6px;
        overflow: hidden;
    }
    #mediaPlayer, #externalPlayer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        border: none;
        background:#000; /* Garante fundo preto para vídeo */
        z-index: 1; /* */
    }
    #controls{
      margin:1rem;
      display:flex;
      gap:.5rem;
      flex-wrap:wrap; /* Quebra botões em múltiplas linhas se necessário */
      position:relative;
      z-index:1;
      justify-content: center; /* Centraliza os botões */
    }
    .btn{
      background:#ff4500;
      border:none; /* */
      color:#FFF;
      padding:.5rem 1rem;
      border-radius:5px;
      cursor:pointer;
      z-index:1;
      font-size: 0.9rem; /* Ajuste para botões */
    }
    .btn:hover {
        opacity: 0.9; /* */
    }

    /* Estilos do Chat */
    #chatArea{
      flex:1; /* Ocupa 1/3 do espaço disponível */
      display:flex;
      flex-direction:column;
      background:#1f1f1f;
      border-left:1px solid #333;
      position:relative; /* */
      border-radius: 8px;
      margin-left: 0.5rem; /* Espaçamento entre player e chat no PC */
    }
    #chatLog{
      flex:1; /* */
      overflow-y:auto;
      padding:.5rem;
      word-wrap: break-word; /* Quebra palavras longas */
    }
    #chatInputArea{
        padding:.5rem; /* */
        display:flex; /* Usa flexbox para alinhar input e botões */
        gap:.5rem; /* */
        border-top: 1px solid #333; /* Separador para a área de input */
        align-items: flex-end; /* Alinha os itens pela parte de baixo */
    }
    #chatInput{
        flex:1; /* */
        padding:.5rem; /* */
        border-radius:4px;
        border:none;
        background:#222;
        color:#EEE;
        resize: vertical; /* Permite redimensionar verticalmente */
        max-height: 150px; /* Limite de altura para não "estourar" o layout */
        min-height: 40px; /* Altura mínima para o textarea */
        min-width: 100px; /* Largura mínima para o textarea */
        overflow: auto; /* Garante que o conteúdo tenha scroll se o textarea for menor que o conteúdo */
    }
    #sendChatBtn, #shareRoomCodeBtn {
        height: 40px; /* Ajusta altura dos botões para alinhar com o input */
        flex-shrink: 0; /* Impede que os botões diminuam */
        padding: 0.5rem 0.8rem; /* Ajusta padding */
    }
    #shareRoomCodeBtn {
        background-color: #007bff; /* Cor diferente para o botão de compartilhar */
        display: flex;
        align-items: center; /* */
        justify-content: center; /* */
    }
    #shareRoomCodeBtn svg {
        width: 18px;
        height: 18px; /* */
        fill: white;
    }

    /* Estilos dos Modais (Padrão para Telas Maiores) */
    #fileMenuModal, #participantListModal, #playlistModal{
      position:fixed; /* */
      top:0; /* */
      left:0; /* */
      right:0; /* */
      bottom:0; /* */
      background:rgba(0,0,0,0.75);
      display:none;
      justify-content:center;
      align-items:center;
      z-index:9999;
    }
    #fileMenuContent, #participantListContent, #playlistContent{
      background:#333; /* */
      padding:1.5rem; /* */
      border-radius:8px;
      min-width:320px;
      display:flex;
      flex-direction:column;
      gap:.75rem;
      position:relative;
      max-height:90vh;
      overflow-y:auto;
    }
    .closeBtn{
      position:absolute; /* */
      top:10px; /* */
      right:10px; /* */
      background:#a00;
      color:#fff;
      border:none;
      border-radius:50%;
      width:24px;
      height:24px;
      font-weight:bold;
      cursor:pointer;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 1.2rem; /* */
    }

    /* Estilos de Itens da Playlist/Participantes */
    .playlistItem{display:flex;justify-content:space-between;align-items:center;padding:.5rem;margin-bottom:.3rem;background:#2a2a2a; /* */
    border-radius: 4px;}
    .playlistItem span{flex:1;text-align:left;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}
    .playlistItem small{opacity:0.7; /* */
    margin-left: 0.5rem;}
    #rejectedNotice img {width: 64px;height: 64px;margin-bottom: 0.5rem;}

    /* Classe para mensagens privadas (comandos) */
    .private-message {
        color: #ff9933; /* Vermelho-alaranjado */
        font-style: italic; /* */
    }
    .system-message {
        color: #aaa;
        font-style: italic; /* */
    }
    .warning-message {
        color: yellow;
        font-style: italic; /* */
    }

    /* --- MEDIA QUERIES --- */

    /* Para Telas de Telefone/Tablet (Largura máxima de 768px) */
    @media (max-width: 768px) {
      body {
        justify-content: flex-start; /* Alinha o conteúdo ao topo para não haver espaço vazio */
      }

      /* Menu Inicial, Nome de Usuário, Espera e Recusa */
      #menuSetup, #namePrompt, #waitingApproval, #rejectedNotice {
        width: 90%; /* Ocupa a maior parte da largura */
        max-width: 400px; /* Mas não fica muito grande */
        margin: auto; /* Centraliza horizontalmente */
        padding: 1.5rem; /* Mais espaçamento */
        border-radius: 8px;
        background: #1f1f1f; /* Fundo para se destacar */
      }
      #menuSetup input, #namePrompt input {
        width: 100%; /* */
        padding: 0.8rem;
        font-size: 1rem;
      }
      #menuSetup .btn, #namePrompt .btn, #rejectedNotice .btn {
        width: 100%; /* */
        padding: 0.8rem;
        font-size: 1rem;
      }

      /* Layout Principal dentro da Sala (Mobile) */
      #mainUI{
        flex-direction:column; /* Player em cima, chat embaixo */
        width:100%; /* Ocupa 100% da largura */
        height:100vh; /* Ocupa a altura total da viewport */
        padding:.5rem; /* Menor padding */
      }
      #playerArea{
        width:100%; /* Player ocupa 100% da largura */
        height: auto; /* Altura automática */
        padding: 0.5rem;
        border-radius: 0; /* Remove bordas arredondadas em mobile para melhor preenchimento */
      }
      #mediaPlayerContainer {
        max-width: none; /* Remove limite de largura para preencher a tela */
        border-radius: 0; /* */
      }
      #controls {
        margin-top: 0.5rem; /* Ajusta margem para os botões */
      }
      #chatArea{
        width:100%; /* Chat ocupa 100% da largura */
        height:150px; /* Altura fixa para o chat em mobile */
        border-left:none; /* Remove borda esquerda */
        border-top:1px solid #333; /* Adiciona borda superior */
        margin-top:.5rem; /* Espaçamento entre player e chat */
        margin-left: 0; /* Remove margem esquerda */
        border-radius: 0; /* Remove bordas arredondadas */
      }
      #chatInputArea {
        /* No mobile, os botões ficam ao lado do textarea */
        flex-direction: row; /* Mantém em linha */
        align-items: flex-end; /* Alinha na parte de baixo */
      }
      #chatInput {
          max-height: 100px; /* Limita a altura do input em mobile */
          min-height: 35px; /* */
          resize: vertical; /* Permite redimensionar verticalmente apenas em mobile */
      }
      #shareRoomCodeBtn {
          /* No mobile, o botão de compartilhar deve ficar visível */
          display: flex; /* */
          order: -1; /* Coloca o botão de compartilhar antes do input */
      }
      #sendChatBtn {
          order: 1; /* Coloca o botão de enviar depois do input */
      }
    }

    /* Para Telas de TV (Largura mínima de 1600px, adaptando seu breakpoint) */
    @media (min-width: 1600px) {
      #mainUI{
        max-width:1800px; /* Aumenta a largura máxima para TVs */
        margin:2rem auto;
        border:1px solid #444; /* */
        border-radius:10px;
        box-shadow:0 0 20px #0008;
        padding: 1.5rem; /* Mais padding interno */
      }

      #playerArea {
        padding: 1.5rem; /* Mais padding interno */
        flex: 3; /* Player ocupa mais espaço */
      }
      #mediaPlayerContainer {
        max-width: 1000px; /* Aumenta o max-width do vídeo */
      }

      #chatArea{
        flex: 1; /* Chat ocupa menos espaço proporcionalmente */
        max-width: 350px; /* Largura fixa para o chat em TVs */
        margin-left: 1.5rem; /* Mais espaçamento */
        height: auto; /* Altura automática */
      }

      /* Modais para TV (Posicionados sem cobrir tudo) */
      #fileMenuModal, #participantListModal, #playlistModal {
        background:rgba(0,0,0,0.5); /* Fundo um pouco mais transparente */
      }
      #fileMenuContent, #participantListContent, #playlistContent {
        min-width: 400px; /* Aumenta o tamanho mínimo dos modais */
        max-width: 600px;
        position: absolute; /* Permite posicionamento absoluto */
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%); /* Centraliza modais */
      }
      /* Ajuste específico para posicionar modais próximos ao chat */
      #participantListModal #participantListContent,
      #playlistModal #playlistContent {
          top: 2rem; /* Mais perto do topo */
          right: 2rem; /* Alinhado à direita */
          left: unset; /* Desativa centralização horizontal */
          transform: unset; /* Remove transform */
          margin-left: auto; /* Empurra para a direita */
          margin-right: 0; /* */
      }
      #fileMenuModal #fileMenuContent {
          top: 2rem; /* */
          left: 2rem; /* */
          right: unset;
          transform: unset;
          margin-left: 0;
          margin-right: auto; /* */
      }
    }

    /* Estilos para o rejectedNotice (mantém o flex-direction) */
    #rejectedNotice {
      flex-direction: column; /* */
      gap: 0.5rem;
      align-items: center;
    }
  </style>
</head>
<body>
  <div id="menuSetup">
    <label for="roomCode" class="sr-only">Código da sala</label>
    <input id="roomCode" placeholder="Código da sala (ex: A91J)" maxlength="4" style="text-transform:uppercase" aria-label="Campo para inserir o código da sala" />
    <button id="createRoom" class="btn" aria-label="Criar uma nova sala e configurar o nome">Criar Sala</button>
    <button id="joinRoom" class="btn" aria-label="Entrar em uma sala existente com código">Entrar na Sala</button>
  </div>

  <div id="namePrompt" style="display:none;">
    <label for="nickname" class="sr-only">Nome de usuário</label>
    <input id="nickname" placeholder="Seu nome de usuário" aria-label="Campo para inserir o seu nome"/>
    <button id="enterRoom" class="btn" aria-label="Confirmar e entrar na sala">Entrar</button> </div>

  <div id="waitingApproval" style="display:none;">
    <img src="https://media.tenor.com/On7kvXhzml4AAAAj/loading-gif.gif" alt="Carregando" width="64" height="64"/>
    <p aria-live="assertive">Esperando o Administrador aceitar sua solicitação :D</p>
  </div>

  <div id="rejectedNotice" style="display:none;">
    <img src="https://img.freepik.com/free-icon/cancel_318-10762.jpg" alt="Recusado"/>
    <p>O Administrador (A) da sala recusou a sua solicitação de entrada :(</p>
    <button id="retryEntryBtn" class="btn">Tentar novamente</button>
  </div>
  <div id="mainUI">
    <div id="playerArea">
      <div id="mediaPlayerContainer">
        <video id="mediaPlayer" controls autoplay></video>
        </div>
      <div id="controls">
        <button id="chooseMediaBtn" class="btn" aria-label="Abrir opções para adicionar mídia">Escolher Arquivo/Link/Tela</button> <button id="showPlaylistBtn" class="btn" aria-label="Ver lista de reprodução">📃 Playlist</button>
        <button id="showParticipantsBtn" class="btn" aria-label="Mostrar participantes da sala">👥 Participantes</button>
      </div>
    </div>
    <div id="chatArea">
      <div id="chatLog" aria-live="polite"></div>
      <div id="chatInputArea">
        <label for="chatInput" class="sr-only">Mensagem</label>
        <textarea id="chatInput" placeholder="Digite sua mensagem (máx 900 caracteres)" autocomplete="off" aria-label="Campo de mensagem" maxlength="900" rows="2"></textarea>
        <button id="shareRoomCodeBtn" class="btn" aria-label="Compartilhar código da sala">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.52.47 1.2.77 1.96.77 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L7.94 11.3c-.52-.47-1.2-.77-1.96-.77-1.66 0-3 1.34-3 3s1.34 3 3 3c.76 0 1.44-.3 1.96-.77l7.05 4.11c-.05.23-.09.46-.09.7 0 1.66 1.34 3 3 3s3-1.34 3-3-1.34-3-3-3z"/></svg>
        </button>
        <button id="sendChatBtn" class="btn" aria-label="Enviar mensagem">Enviar</button>
      </div>
    </div>
  </div>

  <div id="fileMenuModal">
    <div id="fileMenuContent"> <button class="closeBtn" onclick="document.getElementById('fileMenuModal').style.display='none'" aria-label="Fechar menu de mídia">×</button>
      <button id="selectFileBtn" class="btn" aria-label="Escolher um arquivo de vídeo ou áudio do seu dispositivo">Escolher do dispositivo</button>
      <button id="insertLinkBtn" class="btn" aria-label="Inserir um link direto para o vídeo">Inserir link de Mídia</button>
      <button id="shareScreenBtn" class="btn" aria-label="Transmitir a tela ao vivo">Transmitir Tela</button>
    </div>
  </div>

  <div id="participantListModal">
    <div id="participantListContent">
      <button class="closeBtn" onclick="document.getElementById('participantListModal').style.display='none'" aria-label="Fechar lista de participantes">×</button>
      <div id="participantList"></div>
    </div> </div>

  <div id="playlistModal">
    <div id="playlistContent">
      <button class="closeBtn" onclick="document.getElementById('playlistModal').style.display='none'" aria-label="Fechar lista de reprodução">×</button>
      <div id="playlistItems"></div>
    </div>
  </div>

  <audio id="memeSound" src="https://actions.google.com/sounds/v1/cartoon/cartoon_boing.ogg" preload="auto"></audio>

  <script>
    let isCreatingRoom = false;
    let myName = '';
    let roomID = ''; // Variável global para armazenar o código da sala

    let isAdmin = false; // Flag para verificar se o usuário atual é o administrador
    let approvalTimeout = null;
    let waitingForApproval = false;

    // Dados que serão sincronizados via localStorage
    let playlist = [];
    let participants = [];
    let validRooms = new Set(); // Armazena todos os IDs de salas válidas
    let bannedUsers = new Map(); // Map(nomeDoUsuario, { banUntil: timestamp, reason: 'motivo' })

    const LOCAL_STORAGE_PREFIX = 'myChatApp_roomState_';
    const LOCAL_STORAGE_PENDING_REQUESTS = 'myChatApp_pendingJoinRequests';

    // --- Funções de Sincronização com localStorage ---
    function saveRoomState(id, state) {
        localStorage.setItem(LOCAL_STORAGE_PREFIX + id, JSON.stringify(state));
    }

    function loadRoomState(id) {
        const storedState = localStorage.getItem(LOCAL_STORAGE_PREFIX + id);
        if (storedState) {
            const state = JSON.parse(storedState);
            // Reconstroi o Set e o Map
            state.validRooms = new Set(state.validRooms);
            state.bannedUsers = new Map(state.bannedUsers);
            return state;
        }
        return null;
    }

    // Função para atualizar o estado global da sala e salvar no localStorage
    function updateRoomStateInLocalStorage() {
        if (!roomID) return; // Só atualiza se estiver em uma sala
        const state = {
            roomID: roomID,
            participants: participants,
            playlist: playlist,
            validRooms: Array.from(validRooms),
            bannedUsers: Array.from(bannedUsers.entries())
        };
        saveRoomState(roomID, state);
    }

    // Função para buscar o estado mais recente de uma sala específica (útil para quem entra)
    function fetchAndUpdateLocalRoomData(id) {
        const state = loadRoomState(id);
        if (state) {
            // Atualiza apenas as variáveis que precisam ser sincronizadas
            validRooms = state.validRooms;
            participants = state.participants; // Sincroniza a lista de participantes
            playlist = state.playlist; // Sincroniza a playlist
            bannedUsers = state.bannedUsers; // Sincroniza usuários banidos
            updateParticipantList(); // Redesenha a lista de participantes
            updatePlaylist(); // Redesenha a playlist
            console.log(`[DEBUG] Dados da sala ${id} atualizados localmente.`);
        }
    }

    // --- Listener para eventos de storage (sincronização entre abas) ---
    window.addEventListener('storage', (event) => {
        // Se o evento for para o estado da sala que estamos, atualiza
        if (event.key && event.key.startsWith(LOCAL_STORAGE_PREFIX)) {
            const changedRoomID = event.key.substring(LOCAL_STORAGE_PREFIX.length);
            if (changedRoomID === roomID) {
                console.log(`[STORAGE EVENT] Estado da sala ${changedRoomID} mudou. Atualizando dados locais.`);
                fetchAndUpdateLocalRoomData(changedRoomID);
            }
        }
        // Se o evento for para pedidos de entrada pendentes, e esta aba é a do admin
        if (event.key === LOCAL_STORAGE_PENDING_REQUESTS && isAdmin) {
            handleIncomingJoinRequest();
        }
    });

    // --- Funções de Pedidos de Entrada (Admin) ---
    // Simula um pedido de entrada sendo colocado no localStorage
    function sendJoinRequest(requestingName, targetRoomID) {
        const requests = JSON.parse(localStorage.getItem(LOCAL_STORAGE_PENDING_REQUESTS) || '[]');
        // Adiciona um identificador único para o pedido para evitar duplicatas e permitir rejeições específicas
        const requestId = `${targetRoomID}-${requestingName}-${Date.now()}`;
        requests.push({ id: requestId, roomID: targetRoomID, name: requestingName, status: 'pending' });
        localStorage.setItem(LOCAL_STORAGE_PENDING_REQUESTS, JSON.stringify(requests));
        console.log(`[DEBUG] Pedido de entrada de ${requestingName} para ${targetRoomID} enviado.`);
    }

    // Simula a resposta do administrador para um pedido de entrada
    function respondToJoinRequest(requestId, approved) {
        let requests = JSON.parse(localStorage.getItem(LOCAL_STORAGE_PENDING_REQUESTS) || '[]');
        const requestIndex = requests.findIndex(req => req.id === requestId);

        if (requestIndex !== -1) {
            requests[requestIndex].status = approved ? 'approved' : 'rejected';
            localStorage.setItem(LOCAL_STORAGE_PENDING_REQUESTS, JSON.stringify(requests));
            console.log(`[DEBUG] Pedido ${requestId} ${approved ? 'aprovado' : 'rejeitado'}.`);
        }
    }

    // Função para o administrador verificar e processar pedidos de entrada
    function handleIncomingJoinRequest() {
        if (!isAdmin || !roomID) return;

        let requests = JSON.parse(localStorage.getItem(LOCAL_STORAGE_PENDING_REQUESTS) || '[]');
        const pendingRequestsForMyRoom = requests.filter(req => req.roomID === roomID && req.status === 'pending');

        if (pendingRequestsForMyRoom.length > 0) {
            pendingRequestsForMyRoom.forEach(request => {
                // Remove o pedido pendente do localStorage para que não seja processado novamente
                requests = requests.filter(req => req.id !== request.id);
                localStorage.setItem(LOCAL_STORAGE_PENDING_REQUESTS, JSON.stringify(requests));

                const aprovado = confirm(`O participante ${request.name} quer entrar na sala ${request.roomID}. Aceitar?`);
                respondToJoinRequest(request.id, aprovado);
            });
        }
    }

    // Inicia a verificação periódica de pedidos de entrada para o admin
    // Isso é um fallback se o evento 'storage' não for suficiente
    setInterval(() => {
        if (isAdmin && roomID) {
            handleIncomingJoinRequest();
        }
    }, 1000); // Verifica a cada segundo

    // --- Funções Auxiliares de UI/Chat (existentes no seu código) ---
    function addSystemMessage(msg) {
      const chatLog = document.getElementById('chatLog');
      const p = document.createElement('p');
      p.classList.add('system-message');
      p.textContent = msg;
      chatLog.appendChild(p);
      chatLog.scrollTop = chatLog.scrollHeight;
      const roomCodeMatch = msg.match(/\[Sistema: Código da Sala \((\w{4})\)\]/);
      if (roomCodeMatch && roomCodeMatch[1]) {
          const newRoomCode = roomCodeMatch[1];
          validRooms.add(newRoomCode);
          console.log(`[DEBUG] Sala ${newRoomCode} adicionada a validRooms globalmente.`);
          updateRoomStateInLocalStorage(); // Atualiza o localStorage com o novo roomID
      }
    }

    function addPrivateMessage(msg, isWarning = false) {
      const chatLog = document.getElementById('chatLog');
      const p = document.createElement('p');
      p.classList.add('private-message');
      if (isWarning) {
        p.classList.add('warning-message');
      }
      p.textContent = `[Você]: ${msg}`;
      chatLog.appendChild(p);
      chatLog.scrollTop = chatLog.scrollHeight;
    }

    function addChatMessage(sender, message) {
      const chatLog = document.getElementById('chatLog');
      const p = document.createElement('p');
      p.textContent = `${sender}: ${message}`;
      chatLog.appendChild(p);
      chatLog.scrollTop = chatLog.scrollHeight;
    }

    function updateParticipantList() {
      const list = document.getElementById('participantList');
      list.innerHTML = '';
      if (participants.length === 0) {
        list.textContent = 'Nenhum participante na sala.';
        return;
      }
      participants.forEach(p => {
        const div = document.createElement('div');
        div.className = 'playlistItem';
        let role = '';
        if (p.isAdmin) role = '(admin)';
        else if (p.isMod) role = '(mod)';
        div.textContent = `${p.name} ${role}`;
        list.appendChild(div);
      });
      updateRoomStateInLocalStorage(); // Atualiza localStorage quando a lista de participantes muda
    }

    function updatePlaylist() {
      const list = document.getElementById('playlistItems');
      list.innerHTML = '';
      if (playlist.length === 0) {
        list.textContent = 'Playlist vazia.';
        return;
      }
      playlist.forEach(item => {
        const div = document.createElement('div');
        div.className = 'playlistItem';
        const span = document.createElement('span');
        span.textContent = item.name;
        const small = document.createElement('small');
        small.textContent = `${item.type.toUpperCase()} - adicionado por ${item.addedBy}`;
        div.appendChild(span);
        div.appendChild(small);
        list.appendChild(div);
      });
      updateRoomStateInLocalStorage(); // Atualiza localStorage quando a playlist muda
    }

    // Mostrar modais
    document.getElementById('chooseMediaBtn').onclick = () => {
      document.getElementById('fileMenuModal').style.display = 'flex';
    };

    document.getElementById('showParticipantsBtn').onclick = () => {
      updateParticipantList();
      document.getElementById('participantListModal').style.display = 'flex';
    };
    document.getElementById('showPlaylistBtn').onclick = () => {
      updatePlaylist();
      document.getElementById('playlistModal').style.display = 'flex';
    };
    // Escolher arquivo do dispositivo
    document.getElementById('selectFileBtn').onclick = () => {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'video/*,audio/*';
      input.onchange = () => {
        const file = input.files[0];
        if (file) {
          const url = URL.createObjectURL(file);
          playAndBroadcast(url, 'arquivo', file.name);
          document.getElementById('fileMenuModal').style.display = 'none';
        }
      };
      input.click();
    };

    // Inserir link
    document.getElementById('insertLinkBtn').onclick = () => {
      const url = prompt('Insira o link do vídeo, áudio ou live (YouTube, Twitch, Vimeo, DailyMotion, SoundCloud):');
      if (!url) return;

      let mediaType = 'link';
      let mediaName = 'Link Externo';
      let processedUrl = url;
      let isValidEmbedOrDirectLink = false;

      const youtubeMatch = url.match(/(?:youtube\.com\/(?:[^\/\n\s]+\/\S+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([a-zA-Z0-9_-]{11})/);
      const twitchMatch = url.match(/(?:twitch\.tv\/([a-zA-Z0-9_]+)(?:\/videos\/(\d+))?)/);
      const vimeoMatch = url.match(/(?:vimeo\.com\/(?:video\/)?([0-9]+))/);
      const dailymotionMatch = url.match(/(?:dailymotion\.com\/(?:video|hub)\/([a-zA-Z0-9]+))/);
      const soundcloudMatch = url.match(/(?:soundcloud\.com|snd\.sc)\/(.*)/);
      const directMediaMatch = /\.(mp4|webm|ogg|mp3|wav)(\?.*)?$/i.test(url);


      if (youtubeMatch) {
          processedUrl = `http://www.youtube.com/embed/${youtubeMatch[1]}?autoplay=1&controls=1`; // CORRIGIDO: URL correta para embed do YouTube
          mediaName = 'YouTube Video';
          mediaType = 'youtube';
          isValidEmbedOrDirectLink = true;
      } else if (twitchMatch) {
          const channel = twitchMatch[1];
          const videoId = twitchMatch[2];
          if (videoId) { // Twitch VOD
              processedUrl = `https://player.twitch.tv/?video=${videoId}&parent=${window.location.hostname}&autoplay=true`;
              mediaName = 'Twitch VOD';
              mediaType = 'twitch_vod';
          } else { // Twitch Live Stream
              processedUrl = `https://player.twitch.tv/?channel=${channel}&parent=${window.location.hostname}&autoplay=true`;
              mediaName = `Twitch Live: ${channel}`;
              mediaType = 'twitch_live';
          }
          isValidEmbedOrDirectLink = true;
      } else if (vimeoMatch) {
          processedUrl = `https://player.vimeo.com/video/${vimeoMatch[1]}?autoplay=1`;
          mediaName = 'Vimeo Video';
          mediaType = 'vimeo';
          isValidEmbedOrDirectLink = true;
      } else if (dailymotionMatch) {
          processedUrl = `https://www.dailymotion.com/embed/video/${dailymotionMatch[1]}?autoplay=1`;
          mediaName = 'DailyMotion Video';
          mediaType = 'dailymotion';
          isValidEmbedOrDirectLink = true;
      } else if (soundcloudMatch) {
          mediaName = 'SoundCloud Audio';
          mediaType = 'soundcloud';
          isValidEmbedOrDirectLink = true;
      } else if (directMediaMatch) { // Arquivo de vídeo/áudio direto
          mediaName = url.split('/').pop().split('?')[0];
          mediaType = 'direct_media';
          isValidEmbedOrDirectLink = true;
      } else if (url.startsWith('https://') || url.startsWith('http://')) {
          addPrivateMessage('Aviso: O link inserido não é um formato de mídia reconhecido (vídeo/áudio direto ou serviço embed). Pode não funcionar como esperado.', true);
          mediaName = url;
          mediaType = 'unknown_link';
          isValidEmbedOrDirectLink = true;
      }

      if (!isValidEmbedOrDirectLink) {
          alert('Link inválido. Por favor, insira um link direto de mídia ou de um serviço suportado (YouTube, Twitch, Vimeo, DailyMotion, SoundCloud).');
          return;
      }

      playAndBroadcast(processedUrl, mediaType, mediaName);
      document.getElementById('fileMenuModal').style.display = 'none';
    };

    // Compartilhar tela
    document.getElementById('shareScreenBtn').onclick = async () => {
      try {
        const stream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
        const mediaPlayerContainer = document.getElementById('mediaPlayerContainer');
        mediaPlayerContainer.innerHTML = '';
        const video = document.createElement('video');
        video.id = 'mediaPlayer';
        video.controls = true;
        video.autoplay = true;
        video.srcObject = stream;
        mediaPlayerContainer.appendChild(video);
        
        broadcastMedia('tela', 'Compartilhamento de tela');
        document.getElementById('fileMenuModal').style.display = 'none';
      } catch (err) {
        alert('Erro ao compartilhar tela: ' + err);
      }
    };

    // Reseta player antes de tocar nova mídia
    function resetPlayer() {
      const mediaPlayerContainer = document.getElementById('mediaPlayerContainer');
      mediaPlayerContainer.innerHTML = '';
      const video = document.createElement('video');
      video.id = 'mediaPlayer';
      video.controls = true;
      video.autoplay = true;
      mediaPlayerContainer.appendChild(video);
    }

    // Função que toca e adiciona na playlist, simulando broadcast
    function playAndBroadcast(url, type, name) {
        resetPlayer();

        const mediaPlayerContainer = document.getElementById('mediaPlayerContainer');
        const videoPlayer = document.getElementById('mediaPlayer');

        if (type === 'youtube' || type === 'twitch_live' || type === 'twitch_vod' || type === 'vimeo' || type === 'dailymotion') {
            const iframe = document.createElement('iframe');
            iframe.id = 'externalPlayer';
            iframe.src = url;
            iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share';
            iframe.allowFullscreen = true;
            iframe.setAttribute('frameborder', '0');
            
            mediaPlayerContainer.innerHTML = '';
            mediaPlayerContainer.appendChild(iframe);
        } else if (type === 'soundcloud') {
            const iframe = document.createElement('iframe');
            iframe.id = 'externalPlayer';
            iframe.src = `https://w.soundcloud.com/player/?url=${encodeURIComponent(url)}&color=%23ff5500&auto_play=true&hide_related=false&show_comments=true&show_user=true&show_reposts=false&show_teaser=true`;
            iframe.height = '166';
            iframe.scrolling = 'no';
            iframe.frameBorder = 'no';
            iframe.allow = 'autoplay';
            
            mediaPlayerContainer.innerHTML = '';
            mediaPlayerContainer.appendChild(iframe);
        }
        else {
            videoPlayer.src = url;
            videoPlayer.play();
        }

        playlist.push({name, type, addedBy: myName, url});
        updatePlaylist(); // Isso já chama updateRoomStateInLocalStorage
        
        broadcastMedia(url, type, name);
    }

    // Simula broadcast de mídia (placeholder)
    function broadcastMedia(url, type, name) {
      console.log(`[Broadcast] ${myName} adicionou ${name} (${type}) com URL: ${url}`);
    }

    // Simula o recebimento de mídia por outros usuários (apenas para debug/exemplo)
    function receiveMediaBroadcast(url, type, name) {
        console.log(`[Recebido] Recebendo mídia: ${name} (${type}) com URL: ${url}`);
        playAndBroadcast(url, type, name);
    }


    // Função para processar o link de convite na URL
    function processInviteLink() {
        const urlParams = new URLSearchParams(window.location.search);
        const code = urlParams.get('CODE');
        if (code) {
            document.getElementById('roomCode').value = code;
        }
    }

    // Criar sala
    document.getElementById('createRoom').onclick = () => {
      isCreatingRoom = true;
      roomID = Math.random().toString(36).substring(2, 6).toUpperCase();
      // Ao criar a sala, adiciona ela globalmente (no localStorage)
      let allRooms = JSON.parse(localStorage.getItem('myChatApp_allRooms') || '[]');
      if (!allRooms.includes(roomID)) {
          allRooms.push(roomID);
          localStorage.setItem('myChatApp_allRooms', JSON.stringify(allRooms));
      }
      validRooms.add(roomID); // Adiciona ao Set local também
      
      isAdmin = true;
      document.getElementById('menuSetup').style.display = 'none';
      document.getElementById('namePrompt').style.display = 'flex';
    };

    // Entrar sala
    document.getElementById('joinRoom').onclick = () => {
      isCreatingRoom = false;
      isAdmin = false; // Quem entra não é admin por padrão
      const inputRoomCode = document.getElementById('roomCode').value.trim().toUpperCase();
      if (!inputRoomCode) {
        alert('Por favor, insira o código da sala.');
        return;
      }

      // Verifica se a sala existe globalmente (no localStorage)
      const allRooms = JSON.parse(localStorage.getItem('myChatApp_allRooms') || '[]');
      if (!allRooms.includes(inputRoomCode)) {
        alert(`Sala "${inputRoomCode}" não existe ou foi deletada.`);
        document.getElementById('roomCode').value = '';
        return;
      }

      roomID = inputRoomCode; // Define o roomID para a sala que está sendo acessada
      // Tenta carregar o estado da sala para pegar participantes/playlist antes de entrar
      fetchAndUpdateLocalRoomData(roomID);

      document.getElementById('menuSetup').style.display = 'none';
      document.getElementById('namePrompt').style.display = 'flex';
    };

    // Confirmar entrada na sala
    document.getElementById('enterRoom').onclick = async () => {
      myName = document.getElementById('nickname').value.trim();
      if (!myName) {
        alert('Por favor, insira seu nome de usuário.');
        return;
      }

      // Sincroniza bannedUsers antes de verificar
      const storedState = loadRoomState(roomID);
      if (storedState) {
          bannedUsers = storedState.bannedUsers;
      }

      const banInfo = bannedUsers.get(myName);
      if (banInfo && banInfo.banUntil > Date.now()) {
        const remainingTime = Math.ceil((banInfo.banUntil - Date.now()) / (1000 * 60));
        alert(`Você está banido por ${remainingTime} minutos. Motivo: ${banInfo.reason || 'Nenhum.'}`);
        return;
      }

      if (isCreatingRoom) { // Se está criando a sala (é o administrador)
        participants.push({name: myName, isAdmin: true, isMod: false});
        alert(`Sala criada! Código: ${roomID}\nVocê é o administrador.`);
        document.getElementById('namePrompt').style.display = 'none';
        document.getElementById('mainUI').style.display = 'flex';
        updateParticipantList(); // Atualiza a lista e salva no localStorage
        updatePlaylist(); // Salva a playlist vazia no localStorage
        addSystemMessage(`[Sistema: Código da Sala (${roomID})]`);
        addPrivateMessage(`Bem-vindo, ${myName}! Você é o administrador.`);
        updateRoomStateInLocalStorage(); // Garante que o estado inicial da sala está salvo
      } else { // Se está tentando entrar em uma sala existente
        document.getElementById('namePrompt').style.display = 'none';
        document.getElementById('waitingApproval').style.display = 'flex';
        waitingForApproval = true;
        document.getElementById('memeSound').play();

        // Envia o pedido de entrada para o localStorage
        sendJoinRequest(myName, roomID);

        // Espera pela resposta do administrador via localStorage
        let checkApprovalInterval = setInterval(() => {
            let requests = JSON.parse(localStorage.getItem(LOCAL_STORAGE_PENDING_REQUESTS) || '[]');
            const myRequest = requests.find(req => req.roomID === roomID && req.name === myName && req.status !== 'pending');

            if (myRequest) {
                clearInterval(checkApprovalInterval);
                document.getElementById('waitingApproval').style.display = 'none';
                waitingForApproval = false;

                if (myRequest.status === 'approved') {
                    // Após a aprovação, o solicitante também atualiza seus dados localmente com o estado da sala
                    fetchAndUpdateLocalRoomData(roomID);
                    // Adiciona o próprio usuário à lista de participantes e salva (o admin também já fez isso)
                    const existingParticipant = participants.find(p => p.name === myName);
                    if (!existingParticipant) {
                        participants.push({name: myName, isAdmin: false, isMod: false});
                        updateRoomStateInLocalStorage(); // Salva a atualização dos participantes
                    }

                    document.getElementById('mainUI').style.display = 'flex';
                    addSystemMessage(`${myName} entrou na sala.`);
                    addPrivateMessage(`Você foi aceito na sala ${roomID}!`);
                } else { // status === 'rejected'
                    document.getElementById('rejectedNotice').style.display = 'flex';
                    addPrivateMessage(`Sua solicitação para a sala ${roomID} foi recusada.`, true);
                }
                // Remove o pedido do localStorage
                localStorage.setItem(LOCAL_STORAGE_PENDING_REQUESTS, JSON.stringify(requests.filter(req => req.id !== myRequest.id)));
            }
        }, 1000); // Verifica a cada segundo se o status do pedido mudou
      }
    };
    // Botão tentar novamente
    document.getElementById('retryEntryBtn').onclick = () => {
      document.getElementById('rejectedNotice').style.display = 'none';
      document.getElementById('menuSetup').style.display = 'flex';
      document.getElementById('roomCode').value = '';
      document.getElementById('nickname').value = '';
      document.getElementById('roomCode').focus();
    };
    // === FUNÇÃO DE COMANDOS ===
    function handleCommand(message) {
        const parts = message.split(' ');
        const command = parts[0].toLowerCase();
        const targetName = parts[1];
        const restOfMessage = parts.slice(2).join(' ');

        const currentUser = participants.find(p => p.name === myName);
        const canAdmin = currentUser && currentUser.isAdmin;
        const canMod = currentUser && (currentUser.isAdmin || currentUser.isMod);
        switch (command) {
            case '/clear':
            case '/clearall':
                if (canAdmin || canMod) {
                    document.getElementById('chatLog').innerHTML = '';
                    addSystemMessage('O histórico do chat foi limpo por um administrador/moderador.');
                } else {
                    addPrivateMessage('Você não tem permissão para usar este comando.', true);
                }
                return true;

            case '/kick':
                if (canAdmin || canMod) {
                    if (!targetName) {
                        addPrivateMessage('Uso: /Kick (Nome do usuario) (Mensagem)', true);
                        return true;
                    }
                    const kickedUserIndex = participants.findIndex(p => p.name === targetName);
                    if (kickedUserIndex !== -1) {
                        const kickedUser = participants[kickedUserIndex];
                        if (kickedUser.isAdmin && !canAdmin) {
                            addPrivateMessage('Você não pode expulsar outro administrador.', true);
                            return true;
                        }
                         if (kickedUser.isMod && !canAdmin && canMod && kickedUser.name !== myName) {
                            addPrivateMessage('Moderadores não podem expulsar outros moderadores.', true);
                            return true;
                        }
                        if (kickedUser.name === myName) {
                             addPrivateMessage('Você não pode expulsar a si mesmo.', true);
                             return true;
                        }

                        participants.splice(kickedUserIndex, 1);
                        updateParticipantList(); // Isso já chama updateRoomStateInLocalStorage
                        addSystemMessage(`${kickedUser.name} foi expulso da sala. Motivo: ${restOfMessage || 'Nenhum.'}`);
                        if (myName === kickedUser.name) {
                            alert('Você foi expulso da sala!');
                            window.location.reload();
                        }
                    } else {
                        addPrivateMessage(`Usuário "${targetName}" não encontrado.`, true);
                    }
                } else {
                    addPrivateMessage('Você não tem permissão para usar este comando.', true);
                }
                return true;
            case '/ban':
                if (canAdmin) {
                    if (!targetName || !restOfMessage) {
                        addPrivateMessage('Uso: /Ban (Nome do usuario) (Mensagem) (Tempo ex: 10m, 5h, 30s)', true);
                        return true;
                    }
                    const match = restOfMessage.match(/(.*)\s+(\d+[hms])$/i);
                    let reason = 'Nenhum.';
                    let timeStr = '';

                    if (match) {
                        reason = match[1].trim();
                        timeStr = match[2];
                    } else {
                        const lastPart = parts[parts.length - 1];
                        if (lastPart.match(/\d+[hms]/i)) {
                            timeStr = lastPart;
                            reason = parts.slice(2, -1).join(' ').trim();
                        } else {
                            addPrivateMessage('Formato de comando /ban inválido. Uso: /Ban (Nome) (Motivo) (Tempo ex: 10m, 5h, 30s)', true);
                            return true;
                        }
                    }

                    let banDurationMs = 0;
                    const timeValue = parseInt(timeStr.match(/\d+/)[0]);
                    const timeUnit = timeStr.match(/[hms]/i)[0];

                    if (timeUnit.toLowerCase() === 'm') banDurationMs = timeValue * 60 * 1000;
                    else if (timeUnit.toLowerCase() === 'h') banDurationMs = timeValue * 60 * 60 * 1000;
                    else if (timeUnit.toLowerCase() === 's') banDurationMs = timeValue * 1000;
                    else {
                        addPrivateMessage('Formato de tempo inválido (ex: 10m, 5h, 30s).', true);
                        return true;
                    }

                    const banUntil = Date.now() + banDurationMs;
                    bannedUsers.set(targetName, { banUntil, reason: reason || 'Nenhum.' });
                    updateRoomStateInLocalStorage(); // Salva a lista de banidos

                    const bannedUserIndex = participants.findIndex(p => p.name === targetName);
                    if (bannedUserIndex !== -1) {
                        participants.splice(bannedUserIndex, 1);
                        updateParticipantList(); // Isso já chama updateRoomStateInLocalStorage
                    }

                    addSystemMessage(`${targetName} foi banido da sala por ${timeValue}${timeUnit.toLowerCase()}. Motivo: ${reason || 'Nenhum.'}`);
                    if (myName === targetName) {
                        alert('Você foi banido da sala!');
                        window.location.reload();
                    }
                } else {
                    addPrivateMessage('Você não tem permissão para usar este comando.', true);
                }
                return true;
            case '/reload':
            case '/reloadall':
                if (canAdmin) {
                    addSystemMessage('O administrador iniciou um recarregamento da sala. A página será atualizada para todos!');
                    setTimeout(() => window.location.reload(), 2000);
                } else {
                    addPrivateMessage('Você não tem permissão para usar este comando.', true);
                }
                return true;
            case '/admin':
                if (canAdmin) {
                    if (!targetName) {
                        addPrivateMessage('Uso: /Admin (Nome do usuario)', true);
                        return true;
                    }
                    const targetParticipant = participants.find(p => p.name === targetName);
                    if (targetParticipant) {
                        targetParticipant.isAdmin = true;
                        targetParticipant.isMod = false;
                        updateParticipantList(); // Isso já chama updateRoomStateInLocalStorage
                        addSystemMessage(`${targetName} agora é um administrador!`);
                    } else {
                        addPrivateMessage(`Usuário "${targetName}" não encontrado na sala.`, true);
                    }
                } else {
                    addPrivateMessage('Você não tem permissão para usar este comando.', true);
                }
                return true;
            case '/revoke-admin':
                if (canAdmin) {
                    if (!targetName) {
                        addPrivateMessage('Uso: /Revoke-Admin (Nome do usuario)', true);
                        return true;
                    }
                    const targetParticipant = participants.find(p => p.name === targetName);
                    if (targetParticipant && targetParticipant.name !== myName) {
                        targetParticipant.isAdmin = false;
                        updateParticipantList(); // Isso já chama updateRoomStateInLocalStorage
                        addSystemMessage(`${targetName} não é mais um administrador.`);
                    } else if (targetParticipant && targetParticipant.name === myName) {
                        addPrivateMessage('Você não pode remover seus próprios privilégios de administrador. Peça a outro administrador.', true);
                    }
                    else {
                        addPrivateMessage(`Usuário "${targetName}" não encontrado na sala.`, true);
                    }
                } else {
                    addPrivateMessage('Você não tem permissão para usar este comando.', true);
                }
                return true;
            case '/mod':
                if (canAdmin) {
                    if (!targetName) {
                        addPrivateMessage('Uso: /Mod (Nome do usuario)', true);
                        return true;
                    }
                    const targetParticipant = participants.find(p => p.name === targetName);
                    if (targetParticipant) {
                        targetParticipant.isMod = true;
                        updateParticipantList(); // Isso já chama updateRoomStateInLocalStorage
                        addSystemMessage(`${targetName} agora é um moderador!`);
                    } else {
                        addPrivateMessage(`Usuário "${targetName}" não encontrado na sala.`, true);
                    }
                } else {
                    addPrivateMessage('Você não tem permissão para usar este comando.', true);
                }
                return true;
            case '/revoke-mod':
                if (canAdmin) {
                    if (!targetName) {
                        addPrivateMessage('Uso: /Revoke-Mod (Nome do usuario)', true);
                        return true;
                    }
                    const targetParticipant = participants.find(p => p.name === targetName);
                    if (targetParticipant) {
                        targetParticipant.isMod = false;
                        updateParticipantList(); // Isso já chama updateRoomStateInLocalStorage
                        addSystemMessage(`${targetName} não é mais um moderador.`);
                    } else {
                        addPrivateMessage(`Usuário "${targetName}" não encontrado na sala.`, true);
                    }
                } else {
                    addPrivateMessage('Você não tem permissão para usar este comando.', true);
                }
                return true;
            case '/help':
                let helpMessage = "Comandos disponíveis:\n";
                helpMessage += "/Version - Exibe a versão.\n";
                helpMessage += "/Admin - Mostra quem é o admin da sala.\n";
                helpMessage += "/sendlink - Envia um link privado para o admin.\n";
                helpMessage += "/code - Mostra o código da sala.\n";
                helpMessage += "/exit - Sai da sala.\n";
                if (canAdmin) {
                    helpMessage += "\nComandos de Admin:\n";
                    helpMessage += "/Clear All - Limpa o chat.\n";
                    helpMessage += "/Kick (Nome) (Motivo) - Expulsa um usuário.\n";
                    helpMessage += "/Ban (Nome) (Motivo) (Tempo) - Bane um usuário (ex: 10m, 2h).\n";
                    helpMessage += "/reload all - Recarrega a página para todos.\n";
                    helpMessage += "/Admin (Nome) - Concede admin a alguém.\n";
                    helpMessage += "/Revoke-Admin (Nome) - Remove admin de alguém.\n";
                    helpMessage += "/Mod (Nome) - Concede moderador a alguém.\n";
                    helpMessage += "/Revoke-Mod (Nome) - Remove moderador de alguém.\n";
                    helpMessage += "/exitall - Tira todos da sala.\n";
                } else if (canMod) {
                    helpMessage += "\nComandos de Moderador:\n";
                    helpMessage += "/Clear All - Limpa o chat.\n";
                    helpMessage += "/Kick (Nome) (Motivo) - Expulsa um usuário.\n";
                }
                addPrivateMessage(helpMessage);
                return true;

            case '/version':
                addPrivateMessage('Versão Beta ;-)');
                return true;

            case '/admin':
                const currentAdmin = participants.find(p => p.isAdmin);
                if (currentAdmin) {
                    addPrivateMessage(`O administrador da sala é: ${currentAdmin.name}`);
                } else {
                    addPrivateMessage('Não há um administrador definido no momento.', true);
                }
                return true;
            case '/sendlink':
                const linkToSend = prompt('Digite o link que deseja enviar ao administrador:');
                if (linkToSend) {
                    const currentAdmin = participants.find(p => p.isAdmin);
                    if (currentAdmin) {
                        if (myName === currentAdmin.name) {
                            addPrivateMessage(`LINK PRIVADO DO USUÁRIO ${myName}: ${linkToSend}`, true);
                        } else {
                            addPrivateMessage(`O link foi enviado para o administrador (${currentAdmin.name}).`);
                        }
                    } else {
                        addPrivateMessage('Não há um administrador online para receber o link.', true);
                    }
                }
                return true;
            case '/code':
                if (roomID) {
                    addPrivateMessage(`O código da sala é: ${roomID}`);
                } else {
                    addPrivateMessage('Você não está em uma sala ativa.', true);
                }
                return true;
            case '/exit':
                addPrivateMessage('Você saiu da sala.');
                setTimeout(() => window.location.reload(), 1000);
                return true;
            case '/exitall':
                if (canAdmin) {
                    addSystemMessage('O administrador encerrou a sessão. Todos serão redirecionados para o menu principal!');
                    setTimeout(() => window.location.reload(), 2000);
                } else {
                    addPrivateMessage('Você não tem permissão para usar este comando.', true);
                }
                return true;
            default:
                if (message.startsWith('/')) {
                    addPrivateMessage(`Comando desconhecido: ${command}. Digite /help para ver os comandos disponíveis.`, true);
                    return true;
                }
                return false;
        }
    }

    // Sobrescrevendo a função sendMessage para incluir o tratamento de comandos
    function sendMessage() {
      const input = document.getElementById('chatInput');
      let msg = input.value.trim();
      if (!msg) return;

      if (msg.length > 900) {
        alert('Mensagem excede 900 caracteres.');
        return;
      }

      input.value = '';
      if (handleCommand(msg)) {
          return;
      }

      addChatMessage(myName, msg);
      broadcastChatMessage(myName, msg);
    }

    function broadcastChatMessage(sender, message) {
        if (!roomID) return; // Só envia se estiver em uma sala
        const chatMessagesKey = `myChatApp_chatMessages_${roomID}`;
        const messages = JSON.parse(localStorage.getItem(chatMessagesKey) || '[]');
        messages.push({ sender, message, timestamp: Date.now() });
        localStorage.setItem(chatMessagesKey, JSON.stringify(messages));
    }

    // Função para carregar mensagens do chat (apenas para teste, em um app real seria via WebSocket)
    function loadChatMessages() {
        if (!roomID) return;
        const chatLog = document.getElementById('chatLog');
        const chatMessagesKey = `myChatApp_chatMessages_${roomID}`;
        const messages = JSON.parse(localStorage.getItem(chatMessagesKey) || '[]');
        chatLog.innerHTML = ''; // Limpa o chat para recarregar
        messages.forEach(msg => {
            if (msg.sender === 'system') { // Supondo que você pode ter mensagens de sistema persistidas
                const p = document.createElement('p');
                p.classList.add('system-message');
                p.textContent = msg.message;
                chatLog.appendChild(p);
            } else {
                addChatMessage(msg.sender, msg.message);
            }
        });
        chatLog.scrollTop = chatLog.scrollHeight;
    }


    // Função para gerar e compartilhar o link da sala
    async function generateShareLink() {
        if (!roomID) {
            alert('Você precisa estar em uma sala para compartilhar o código.');
            return;
        }

        const currentFile = window.location.pathname.split('/').pop() || 'Player-HTML-CSS-JS.html';
        const shareLink = `${window.location.origin}/${currentFile}?CODE=${roomID}`;

        if (navigator.share) {
            try {
                await navigator.share({
                    title: 'Entrar na Sala!',
                    text: `Junte-se à minha sala! Código: ${roomID}`,
                    url: shareLink,
                });
                addPrivateMessage('Link de compartilhamento enviado com sucesso!', false);
            } catch (error) {
                if (error.name !== 'AbortError') {
                    addPrivateMessage(`Erro ao compartilhar link: ${error.message}`, true);
                }
            }
        } else {
            try {
                await navigator.clipboard.writeText(shareLink);
                addPrivateMessage('Código da sala copiado para a área de transferência! Compartilhe o link: ' + shareLink);
            } catch (err) {
                addPrivateMessage('Falha ao copiar o link. Por favor, copie manualmente: ' + shareLink, true);
            }
        }
    }

    document.getElementById('sendChatBtn').onclick = sendMessage;
    document.getElementById('chatInput').addEventListener('keydown', e => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });
    document.getElementById('shareRoomCodeBtn').onclick = generateShareLink;
    document.getElementById('rejectedNotice').style.display = 'none';

    document.addEventListener('DOMContentLoaded', () => {
        processInviteLink();
        // Carrega todas as salas válidas ao iniciar
        const allRooms = JSON.parse(localStorage.getItem('myChatApp_allRooms') || '[]');
        allRooms.forEach(id => validRooms.add(id));
    });
  </script>
</body>
</html>
